# Problem 1448: Count Good Nodes in Binary Tree
![Medium](https://img.shields.io/badge/Level-Medium-yellow?style=for-the-badge) [![Problem Link](https://img.shields.io/badge/LeetCode-Link-orange?style=for-the-badge&logo=leetcode)](https://leetcode.com/problems/count-good-nodes-in-binary-tree/description/)

## ðŸ Python Solution
```python
class Solution:
    def goodNodes(self, root: TreeNode) -> int:
        def dfs(node, max_val):
            if not node:
                return 0
            
            # Check if current node is "good"
            count = 1 if node.val >= max_val else 0
            
            # Update the max value for the next level
            max_val = max(max_val, node.val)
            
            # Recurse through children and sum up the good nodes
            count += dfs(node.left, max_val)
            count += dfs(node.right, max_val)
            
            return count

        # Start DFS with the root's value as the initial max
        return dfs(root, root.val)
```
<details>
<summary><b>ðŸŸ¦ C++ Solution</b></summary>

```cpp
class Solution {
 public:
  int goodNodes(TreeNode* root, int mx = INT_MIN) {
    if (root == nullptr)
      return 0;
    const int newMax = max(mx, root->val);
    return (root->val >= mx) +              //
           goodNodes(root->left, newMax) +  //
           goodNodes(root->right, newMax);
  }
};
```
</details>
<details>
<summary><b>â˜• Java Solution</b></summary> 

```java
class Solution {
  public int goodNodes(TreeNode root) {
    return goodNodes(root, Integer.MIN_VALUE);
  }

  private int goodNodes(TreeNode root, int mx) {
    if (root == null)
      return 0;

    final int newMax = Math.max(mx, root.val);
    return (root.val >= mx ? 1 : 0) + goodNodes(root.left, newMax) + goodNodes(root.right, newMax);
  }
}
```
</details>

---

## ðŸ”¹ Approach Used

* **Depth-First Search (DFS) with Path Maximum Tracking**
* Traverse the tree using DFS.
* Keep track of the **maximum value seen so far** from the root to the current node.
* A node is considered *good* if its value is greater than or equal to this maximum.
* Update the maximum and continue recursion for left and right subtrees.
* Count all nodes that satisfy the condition.

