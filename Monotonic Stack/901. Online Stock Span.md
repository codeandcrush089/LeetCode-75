# Problem 901: Online Stock Span
![Medium](https://img.shields.io/badge/Level-Medium-yellow?style=for-the-badge) [![Problem Link](https://img.shields.io/badge/LeetCode-Link-orange?style=for-the-badge&logo=leetcode)](https://leetcode.com/problems/online-stock-span/description/)

## ðŸ Python Solution
```python
class StockSpanner:
  def __init__(self):
    self.stack = []  # (price, span)

  def next(self, price: int) -> int:
    span = 1
    while self.stack and self.stack[-1][0] <= price:
      span += self.stack.pop()[1]
    self.stack.append((price, span))
    return span
```
<details>
<summary><b>ðŸŸ¦ C++ Solution</b></summary>

```cpp
class StockSpanner {
 public:
  int next(int price) {
    int span = 1;
    while (!stack.empty() && stack.top().first <= price)
      span += stack.top().second, stack.pop();
    stack.emplace(price, span);
    return span;
  }

 private:
  stack<pair<int, int>> stack;  // (price, span)
};
```
</details>
<details>
<summary><b>â˜• Java Solution</b></summary>  

```java
class StockSpanner {
  public int next(int price) {
    int span = 1;
    while (!stack.isEmpty() && stack.peek().getKey() <= price)
      span += stack.pop().getValue();
    stack.push(new Pair<>(price, span));
    return span;
  }

  // (price, span)
  private Stack<Pair<Integer, Integer>> stack = new Stack<>();
}
```
</details>

---

## ðŸ”¹ Approach Used

* **Monotonic Stack (Decreasing Stack with Span Aggregation)**
* Maintain a stack of pairs `(price, span)` in decreasing price order.
* For each new price, merge spans of all previous prices less than or equal to it.
* Push the current price with its accumulated span.
* Return the span for the current day.

