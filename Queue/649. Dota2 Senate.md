# Problem 649: Dota2 Senate
![Medium](https://img.shields.io/badge/Level-Medium-yellow?style=for-the-badge) [![Problem Link](https://img.shields.io/badge/LeetCode-Link-orange?style=for-the-badge&logo=leetcode)](https://leetcode.com/problems/dota2-senate/description/)

## ðŸ Python Solution
```python
from collections import deque

class Solution:
    def predictPartyVictory(self, senate: str) -> str:
        n = len(senate)
        radiant = deque()
        dire = deque()
        
        # Populate queues with initial indices
        for i, s in enumerate(senate):
            if s == 'R':
                radiant.append(i)
            else:
                dire.append(i)
        
        # Simulate the rounds
        while radiant and dire:
            r_idx = radiant.popleft()
            d_idx = dire.popleft()
            
            # The senator with the smaller index bans the other
            if r_idx < d_idx:
                # Radiant senator bans Dire and moves to next round
                radiant.append(r_idx + n)
            else:
                # Dire senator bans Radiant and moves to next round
                dire.append(d_idx + n)
        
        return "Radiant" if radiant else "Dire"
```
<details>
<summary><b>ðŸŸ¦ C++ Solution</b></summary>

```cpp
class Solution {
public:
    string predictPartyVictory(string senate) {
        int senateSize = senate.size();
      
        // Queue to store indices of Radiant senators
        queue<int> radiantQueue;
        // Queue to store indices of Dire senators
        queue<int> direQueue;
      
        // Initialize queues with initial positions of each party's senators
        for (int i = 0; i < senateSize; ++i) {
            if (senate[i] == 'R') {
                radiantQueue.push(i);
            } else {
                direQueue.push(i);
            }
        }
      
        // Simulate the voting process until one party has no senators left
        while (!radiantQueue.empty() && !direQueue.empty()) {
            // Get the front senator from each party
            int radiantIndex = radiantQueue.front();
            int direIndex = direQueue.front();
            radiantQueue.pop();
            direQueue.pop();
          
            // The senator with smaller index acts first and bans the opponent
            // The winner gets to vote again in the next round (add senateSize to maintain order)
            if (radiantIndex < direIndex) {
                // Radiant senator bans Dire senator and gets next turn
                radiantQueue.push(radiantIndex + senateSize);
            } else {
                // Dire senator bans Radiant senator and gets next turn
                direQueue.push(direIndex + senateSize);
            }
        }
      
        // Return the party name that still has senators
        return radiantQueue.empty() ? "Dire" : "Radiant";
    }
};
```
</details>
<details>
<summary><b>â˜• Java Solution</b></summary> 

```java
class Solution {
    public String predictPartyVictory(String senate) {
        int senateLength = senate.length();
      
        // Queue to store indices of Radiant senators
        Deque<Integer> radiantQueue = new ArrayDeque<>();
        // Queue to store indices of Dire senators
        Deque<Integer> direQueue = new ArrayDeque<>();
      
        // Initialize queues with initial positions of senators
        for (int i = 0; i < senateLength; ++i) {
            if (senate.charAt(i) == 'R') {
                radiantQueue.offer(i);
            } else {
                direQueue.offer(i);
            }
        }
      
        // Simulate the voting process until one party has no senators left
        while (!radiantQueue.isEmpty() && !direQueue.isEmpty()) {
            // Get the indices of the next senators from each party
            int radiantIndex = radiantQueue.poll();
            int direIndex = direQueue.poll();
          
            // The senator with the smaller index acts first and bans the other
            // The winning senator gets to act again in the next round (index + n)
            if (radiantIndex < direIndex) {
                // Radiant senator bans Dire senator and queues for next round
                radiantQueue.offer(radiantIndex + senateLength);
            } else {
                // Dire senator bans Radiant senator and queues for next round
                direQueue.offer(direIndex + senateLength);
            }
        }
      
        // Return the name of the winning party
        return radiantQueue.isEmpty() ? "Dire" : "Radiant";
    }
}
```
</details>

---

## ðŸ”¹ Approach Used

* **Queue Simulation (Greedy Round-Based Process)**
* Use two queues to store the indices of Radiant and Dire senators.
* At each step, compare the front indices:

  * The senator with the smaller index acts first and bans the opponent.
* The winning senator is re-added with an updated index to represent the next round.
* Continue until one queue becomes empty.
