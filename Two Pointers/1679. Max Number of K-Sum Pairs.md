# Problem 1679: Max Number of K-Sum Pairs
![Medium](https://img.shields.io/badge/Level-Medium-yellow?style=for-the-badge) [![Problem Link](https://img.shields.io/badge/LeetCode-Link-orange?style=for-the-badge&logo=leetcode)](https://leetcode.com/problems/max-number-of-k-sum-pairs/description/)

## ðŸ Python Solution
```python
class Solution:
  def maxOperations(self, nums: list[int], k: int) -> int:
    count = collections.Counter(nums)
    return sum(min(count[num], count[k - num])
               for num in count) // 2
```
<details>
<summary><b>ðŸŸ¦ C++ Solution</b></summary>

```cpp
class Solution {
 public:
  int maxOperations(vector<int>& nums, int k) {
    int ans = 0;
    unordered_map<int, int> count;

    for (const int num : nums)
      ++count[num];

    for (const auto& [num, freq] : count)
      if (const auto it = count.find(k - num); it != count.end())
        ans += min(freq, it->second);

    return ans / 2;
  }
};
```
</details>
<details>
<summary><b>â˜• Java Solution</b></summary> 

```java
class Solution {
  public int maxOperations(int[] nums, int k) {
    int ans = 0;
    HashMap<Integer, Integer> count = new HashMap<>();

    for (final int num : nums)
      count.merge(num, 1, Integer::sum);

    for (final int num : count.keySet()) {
      final int complement = k - num;
      if (count.containsKey(complement))
        ans += Math.min(count.get(num), count.get(complement));
    }

    return ans / 2;
  }
}
```
</details>

---

## ðŸ”¹ Approach Used

* **Hash Map (Frequency Counting)**
* Count the frequency of each number using a map.
* For each number `x`, pair it with `k âˆ’ x`.
* The number of valid pairs is limited by the smaller frequency of the two.
* Divide the total by 2 to avoid double-counting pairs.

