# Problem 643: Maximum Average Subarray I
![Easy](https://img.shields.io/badge/Level-Easy-brightgreen?style=for-the-badge) [![Problem Link](https://img.shields.io/badge/LeetCode-Link-orange?style=for-the-badge&logo=leetcode)](https://leetcode.com/problems/maximum-average-subarray-i/description/)

## ðŸ Python Solution
```python
class Solution:
  def findMaxAverage(self, nums: list[int], k: int) -> float:
    summ = sum(nums[:k])
    ans = summ

    for i in range(k, len(nums)):
      summ += nums[i] - nums[i - k]
      ans = max(ans, summ)

    return ans / k
```
<details>
<summary><b>ðŸŸ¦ C++ Solution</b></summary>

```cpp
class Solution {
 public:
  double findMaxAverage(vector<int>& nums, int k) {
    double sum = accumulate(nums.begin(), nums.begin() + k, 0);
    double ans = sum;

    for (int i = k; i < nums.size(); ++i) {
      sum += nums[i] - nums[i - k];
      ans = max(ans, sum);
    }

    return ans / k;
  }
};


```
</details>
<details>
<summary><b>â˜• Java Solution</b></summary> 

```java
class Solution {
  public double findMaxAverage(int[] nums, int k) {
    double sum = 0;
    for (int i = 0; i < k; ++i)
      sum += nums[i];
    double ans = sum;

    for (int i = k; i < nums.length; ++i) {
      sum += nums[i] - nums[i - k];
      ans = Math.max(ans, sum);
    }

    return ans / k;
  }
}
```
</details>

---

## ðŸ”¹ Approach Used

* **Fixed-Size Sliding Window**
* Compute the sum of the first `k` elements.
* Slide the window by adding the next element and removing the element that leaves the window.
* Track the maximum window sum encountered.
* Divide the maximum sum by `k` to get the maximum average.

