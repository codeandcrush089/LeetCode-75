# Problem 1318: Minimum Flips to Make a OR b Equal to c
![Medium](https://img.shields.io/badge/Level-Medium-yellow?style=for-the-badge) [![Problem Link](https://img.shields.io/badge/LeetCode-Link-orange?style=for-the-badge&logo=leetcode)](https://leetcode.com/problems/minimum-flips-to-make-a-or-b-equal-to-c/description/)

## ðŸ Python Solution
```python
class Solution:
  def minFlips(self, a: int, b: int, c: int) -> int:
    MAX_BIT = 30
    ans = 0

    for i in range(MAX_BIT):
      if c >> i & 1:
        ans += (a >> i & 1) == 0 and (b >> i & 1) == 0
      else:  # (c >> i & 1) == 0
        ans += (a >> i & 1) + (b >> i & 1)

    return ans
```

<details>
<summary><b>ðŸŸ¦ C++ Solution</b></summary>

```cpp
class Solution {
 public:
  int minFlips(int a, int b, int c) {
    constexpr int kMaxBit = 30;
    int ans = 0;

    for (int i = 0; i < kMaxBit; ++i)
      if (c >> i & 1)
        ans += (a >> i & 1) == 0 && (b >> i & 1) == 0;
      else  // (c >> i & 1) == 0
        ans += (a >> i & 1) + (b >> i & 1);

    return ans;
  }
};
```
</details>
<details>
<summary><b>â˜• Java Solution</b></summary>  

```java
class Solution {
  public int minFlips(int a, int b, int c) {
    final int MAX_BIT = 30;
    int ans = 0;

    for (int i = 0; i < MAX_BIT; ++i)
      if ((c >> i & 1) == 1)
        ans += ((a >> i & 1) == 0 && (b >> i & 1) == 0) ? 1 : 0;
      else // (c >> i & 1) == 0
        ans += ((a >> i & 1) == 1 ? 1 : 0) + ((b >> i & 1) == 1 ? 1 : 0);

    return ans;
  }
}
```
</details>

---

## ðŸ”¹ Approach Used

* **Bit Manipulation (Bit-by-Bit Analysis)**
* Iterate through each bit position (0 to 30).
* Compare the bits of `a`, `b`, and `c` at the same position.
* If the bit in `c` is `1`, ensure at least one of `a` or `b` is `1`.
* If the bit in `c` is `0`, both bits in `a` and `b` must be `0`.
* Count the minimum flips needed to satisfy `(a OR b) == c`.

