# Problem 875: Koko Eating Bananas
![Medium](https://img.shields.io/badge/Level-Medium-yellow?style=for-the-badge) [![Problem Link](https://img.shields.io/badge/LeetCode-Link-orange?style=for-the-badge&logo=leetcode)](https://leetcode.com/problems/koko-eating-bananas/description/)

## Python Solution
```python
class Solution:
  def minEatingSpeed(self, piles: list[int], h: int) -> int:
    def eatHours(m: int) -> bool:
      """Returns the hours to eat all the piles with speed m."""
      return sum((pile - 1) // m + 1 for pile in piles)
    l = 1
    r = max(piles)
    return bisect.bisect_left(range(l, r), True,
                              key=lambda m: eatHours(m) <= h) + l
```

## C++ Solution
```cpp
class Solution {
 public:
  int minEatingSpeed(vector<int>& piles, int h) {
    int l = 1;
    int r = ranges::max(piles);

    while (l < r) {
      const int m = (l + r) / 2;
      if (eatHours(piles, m) <= h)
        r = m;
      else
        l = m + 1;
    }

    return l;
  }

 private:
  // Returns the hours to eat all the piles with speed m.
  int eatHours(const vector<int>& piles, int m) {
    return accumulate(piles.begin(), piles.end(), 0, [&](int acc, int pile) {
      return acc + (pile - 1) / m + 1;  // ceil(pile / m)
    });
  }
};
```

## Java Solution
```java
class Solution {
  public int minEatingSpeed(int[] piles, int h) {
    int l = 1;
    int r = Arrays.stream(piles).max().getAsInt();

    while (l < r) {
      final int m = (l + r) / 2;
      if (eatHours(piles, m) <= h)
        r = m;
      else
        l = m + 1;
    }

    return l;
  }

  // Returns the hours to eat all the piles with speed m.
  private int eatHours(int[] piles, int m) {
    return Arrays.stream(piles).reduce(
        0, (subtotal, pile) -> subtotal + (pile - 1) / m + 1); // ceil(pile / m)
  }
}
```
