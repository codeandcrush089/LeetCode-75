# Problem 700: Search in a Binary Search Tree
![Easy](https://img.shields.io/badge/Level-Easy-brightgreen?style=for-the-badge) [![Problem Link](https://img.shields.io/badge/LeetCode-Link-orange?style=for-the-badge&logo=leetcode)](https://leetcode.com/problems/search-in-a-binary-search-tree/description/)

## Python Solution
```python
class Solution:
  def searchBST(self, root: TreeNode | None, val: int) -> TreeNode | None:
    if not root:
      return None
    if root.val == val:
      return root
    if root.val > val:
      return self.searchBST(root.left, val)
    return self.searchBST(root.right, val)
```
<details>
<summary><b>ðŸŸ¦ C++ Solution</b></summary>

```cpp
class Solution {
 public:
  TreeNode* searchBST(TreeNode* root, int val) {
    if (root == nullptr)
      return nullptr;
    if (root->val == val)
      return root;
    if (root->val > val)
      return searchBST(root->left, val);
    return searchBST(root->right, val);
  }
};
```
</details>

<details>
<summary><b>â˜• Java Solution</b></summary>

```java
class Solution {
  public TreeNode searchBST(TreeNode root, int val) {
    if (root == null)
      return null;
    if (root.val == val)
      return root;
    if (root.val > val)
      return searchBST(root.left, val);
    return searchBST(root.right, val);
  }
}
```
</details>

---

## ðŸ”¹ Approach Used

* **Binary Search Tree (BST) Recursive Search**
* Compare the target value with the current node.
* If equal, return the node.
* If the target is smaller, search in the left subtree.
* If the target is larger, search in the right subtree.



