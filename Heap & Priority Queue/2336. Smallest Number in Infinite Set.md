# Problem 2336. Smallest Number in Infinite Set
![Medium](https://img.shields.io/badge/Level-Medium-yellow?style=for-the-badge) [![Problem Link](https://img.shields.io/badge/LeetCode-Link-orange?style=for-the-badge&logo=leetcode)](https://leetcode.com/problems/smallest-number-in-infinite-set/description/)

## ðŸ Python Solution
```python
import heapq

class SmallestInfiniteSet:
    def __init__(self):
        # The smallest integer that has never been popped
        self.next_smallest = 1
        # Heap to store numbers that were added back
        self.added_back_heap = []
        # Set to keep track of what's in the heap for O(1) lookups
        self.added_back_set = set()

    def popSmallest(self) -> int:
        # If there are numbers in the added_back heap, they are 
        # guaranteed to be smaller than self.next_smallest
        if self.added_back_heap:
            smallest = heapq.heappop(self.added_back_heap)
            self.added_back_set.remove(smallest)
            return smallest
        
        # Otherwise, the smallest is the current counter
        smallest = self.next_smallest
        self.next_smallest += 1
        return smallest

    def addBack(self, num: int) -> None:
        # We only care if num is smaller than our current counter
        # and not already in our heap of added-back numbers
        if num < self.next_smallest and num not in self.added_back_set:
            heapq.heappush(self.added_back_heap, num)
            self.added_back_set.add(num)
```
<details>
<summary><b>ðŸŸ¦ C++ Solution</b></summary>

```cpp
class SmallestInfiniteSet {
 public:
  int popSmallest() {
    if (added.empty())
      return curr++;
    const int mn = *added.begin();
    added.erase(added.begin());
    return mn;
  }

  void addBack(int num) {
    if (num < curr)
      added.insert(num);
  }

 private:
  int curr = 1;
  set<int> added;
};
```
</details>
<details>
<summary><b>â˜• Java Solution</b></summary> 

```java
class SmallestInfiniteSet {
  public int popSmallest() {
    if (added.isEmpty())
      return curr++;
    final int mn = added.first();
    added.remove(mn);
    return mn;
  }

  public void addBack(int num) {
    if (num < curr)
      added.add(num);
  }

  private int curr = 1;
  private TreeSet<Integer> added = new TreeSet<>();
}
```
</details>
