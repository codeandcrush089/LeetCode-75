# Problem 1071: Greatest Common Divisor of Strings
![Easy](https://img.shields.io/badge/Level-Easy-brightgreen?style=for-the-badge) [![Problem Link](https://img.shields.io/badge/LeetCode-Link-orange?style=for-the-badge&logo=leetcode)](https://leetcode.com/problems/greatest-common-divisor-of-strings/description/)

## ðŸ Python Solution
```python
class Solution:
  def gcdOfStrings(self, str1: str, str2: str) -> str:
    for sz in range(min(len(str1), len(str2)), 0, -1):
      if self._isDivisible(str1, str2, sz):
        return str1[:sz]
    return ''

  def _isDivisible(self, str1: str, str2: str, sz: int) -> bool:
    """Returns True if str1 and str2 are divisible by str1[0..sz)."""
    if len(str1) % sz > 0 or len(str2) % sz > 0:
      return False
    gcd = str1[:sz]
    return str1.replace(gcd, '') == '' and str2.replace(gcd, '') == ''
```
<details>
<summary><b>ðŸŸ¦ C++ Solution</b></summary>
  
```cpp
class Solution {
 public:
  string gcdOfStrings(string str1, string str2) {
    for (int sz = min(str1.length(), str2.length()); sz > 0; --sz)
      if (isDivisible(str1, str2, sz))
        return str1.substr(0, sz);
    return "";
  }

 private:
  // Returns true if str1 and str2 are divisible by str1[0..sz).
  bool isDivisible(const string& str1, const string& str2, int sz) {
    if (str1.length() % sz > 0 || str2.length() % sz > 0)
      return false;
    const string gcd = str1.substr(0, sz);
    return str1 == repeat(gcd, str1.length() / sz) &&
           str2 == repeat(gcd, str2.length() / sz);
  }

  string repeat(const string& s, int n) {
    string res;
    for (int i = 0; i < n; ++i)
      res += s;
    return res;
  }
};
```
</details>
<details>
<summary><b>â˜• Java Solution</b></summary>  
  
```java
class Solution {
  public String gcdOfStrings(String str1, String str2) {
    for (int sz = Math.min(str1.length(), str2.length()); sz > 0; --sz)
      if (isDivisible(str1, str2, sz))
        return str1.substring(0, sz);
    return "";
  }

  // Returns true if str1 and str2 are divisible by str1[0..sz).
  private boolean isDivisible(final String str1, final String str2, int sz) {
    if (str1.length() % sz > 0 || str2.length() % sz > 0)
      return false;
    final String gcd = str1.substring(0, sz);
    return str1.replace(gcd, "").isEmpty() && str2.replace(gcd, "").isEmpty();
  }
}
```
</details>

---

## ðŸ”¹ Logic 

* Try all possible prefix lengths from the **largest to smallest**
  (`min(len(str1), len(str2)) â†’ 1`) to ensure the largest valid answer is found first.

* For a given length `sz`:

  * If `len(str1)` or `len(str2)` is **not divisible by `sz`**, skip this length.
  * Take the prefix `g = str1[0 : sz]` as the candidate divisor.

* Check divisibility:

  * Repeating `g` should exactly reconstruct both `str1` and `str2`.
  * If both strings can be formed only by repeating `g`, it is a valid answer.

* Return the first (largest) valid prefix found.

* If no prefix satisfies the condition, return an empty string `""`.
